use std::thread;use std::time::Duration;fn main() {    let simulated_user_specified_value = 200;    let simulated_random_number = 3;    generate_workout(simulated_user_specified_value, simulated_random_number);}fn generate_workout(num: u32, random: u32) {    let mut cache = Cacher::new(simulated_expensive_calculation);    if num < 25 {        println!("Today, do {} pushups!", cache.value(num));        println!("Next, do {} situps!", cache.value(num));    } else if random == 3 {        println!("Take a break today!");    } else {        println!("Today, run for {} minutes!", cache.value(num));    }}fn simulated_expensive_calculation(intensity: u32) -> u32 {    println!("calculating slowly...");    thread::sleep(Duration::from_secs(2));    intensity}struct Cacher<T> where T: Fn(u32) -> u32 {    calculation: T,    value: Option<u32>,}impl<T> Cacher<T> where T: Fn(u32) -> u32 {    fn new(f: T) -> Cacher<T> {        Cacher {            calculation: f,            value: None,        }    }    fn value(&mut self, arg: u32) -> u32 {        match self.value {            Some(v) => v,            None => {                let v = (self.calculation)(arg);                self.value = Some(v);                v            }        }    }}